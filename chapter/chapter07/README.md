# CHAPTER 7 - 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

- [발표 자료](./chapter7-slide.pdf)

### 안전지대(Safe zone)

안전지대는 불변성이 지켜지는 코드 영역을 의미한다. 안전지대 밖의 영역은 불변성이 보장되지 않는다.

- 안전지대 = 불변성이 지켜지는 영역 = 신뢰할 수 있는 영역
- 안전지대 외부 = 불변성이 지켜지지 않는 영역 = 신뢰할 수 없는 영역

### 방어적 복사(Defensive copy)

방어적 복사란 불변성이 지켜지지 않는 코드와 불변성이 지켜지는 코드 사이의 데이터 통신을 위한 원칙이다. (= 안전지대와 비안전지대 간 데이터 통신을 위한 규칙)

방어적 복사는 데이터의 깊은 복사본을 생성한다. 깊은 복사는 얕은 복사와 달리 참조 주소가 아닌, 값을 복사한다.

### 방어적 복사의 규칙

방아적 복사에는 2가지 규칙이 존재한다.

<b>규칙1: 데이터가 안전한 코드에서 나갈 때 복사하기(안전지대 -> 안전지대 외부)</b>

1. 안전지대의 불변성 데이터의 깊은 복사본을 생성한다.
2. 깊은 복사본 데이터를 반환한다.

<b>규칙2: 안전한 코드로 데이터가 들어올 때 복사하기(안전지대 외부 -> 안전지대)</b>

1. 안전지대 외부의 불변성이 지켜지지 않는 데이터의 깊은 복사본을 생성한다.
2. 깊은 복사본 데이터를 안전지대에서 자유롭게 사용한다.

왜 이런 규칙이 필요할까??

예를 들어, 불변성이 지켜지지 않는 라이브러리를 사용해야 한다고 가정해보자. 참고로 라이브러리 코드는 직접 수정할 수 없는 상황이다.

여기서 라이브러리 코드 영역을 안전지대 외부 영역이라고 분류할 수 있다. 안전지대에서 보내진 데이터가 안전지대 외부 영역인 라이브러리의 코드를 실행하는 중에 변경될 수도 있다. 또한, 라이브러리에서 생성된 코드가 안전지대에 들어온 데이터는 이후에 변경 될 위험도 있다.

이러한 문제점을 해결하기 위해, 안전지대와 안전지대 외부 간 데이터 통신 중 방어적 복사를 적용하여 안전하게 데이터를 처리 할 수 있다. 즉, 데이터의 불변성을 지킬 수 있다.

간단히 방어적 복사를 적용한 코드를 확인해보자.

```js
function addItemToCart(name, price) {
	// ... more code
	shoppingCart = blackFridayPromotionSafe(shoppingCart);
}

function blackFridayPromotionSafe(cart) {
	// 안전지대 데이터의 변경 위험을 맊기 위해 방어적 복사
	const cartCopy = deepClone(shoppingCart);

	// 1. 안전지대 -> 안전지대 외부
	// 안전지대 외부로 나간 데이터는 변경 될 위험이 있음
	blackFridayPromotion(cartCopy);

	// 2. 안전지대 외부 -> 안전지대
	// 안전지대 외부에서 들어온 데이터는 이후에 변경될 위험이 있음
	return deepClone(cartCopy);
}
```

### 카피-온-라이트 VS 방어적 복사

|  | 카피-온-라이트 | 방어적 복사 |
| --- | --- | --- |
| **When** | 안전지대에서 데이터를 통신할 때 | 안전지대와 안전지대 외부 영역간 데이터를 통신할 때 |
| **Where** | 안전지대 | 안전지대 외부와 통신하는 지점 |
| **How** | 얕은 복사(low cost) | 깊은 복사(high cost) |
| **Rule** | 1. 데이터의 얕은 복사본을 생성한다. <br> 2. 복사본을 변경한다. <br> 3. 복사본을 리턴한다 | 안전지대로 들어오거나 나가는 데이터를 깊은 복사 한다. |

### 깊은 복사(Deep clone)

깊은 복사는 중첩된 데이터 전체를 복사하는 방법이다. 얕은 복사와 달리, 참조 주소를 복사하지 않고 값 자체를 복사하기 때문에 비용이 비싸다. 간단히 깊은 복사를 구현해보자.

```js
function deepClone(target) {
	if (Array.isArray(target)) {
		return target.reduce((copy, value) => {
			copy.push(deepClone(value));
			return copy;
		}, []);
	} else if (target !== null && typeof target === 'object') {
		return Array.from(Object.keys(target)).reduce((copy, key) => {
			copy[key] = deepClone(target[key]);
			return copy;
		}, {});
	}

	// primitive type, function, etc
	return target;
}
```

### 생각

깊은 복사는 불변성을 강력하게 지킬 수 있지만 비용이 비싸다. 결국은 성능과 불변성의 정도는 트레이드오프 관계이다.

결국은 데이터를 복사하는 과정에서의 성능을 최적화하기 위해 깊은 복사를 지양하고, 카피-온-라이트를 지향해야 한다.

그런데, 이러한 원칙은 개발 단계에서 모두가 동일하게 지킬 수 없다고 생각한다. 설계 단계에서 어떻게 계층을 나눌지, 어떻게 하면 깊은 복사를 최소화 할 수 있을지 고민해야 할 것 같다.
